/**
 * Copyright (c) 2023 Gitpod GmbH. All rights reserved.
 * Licensed under the GNU Affero General Public License (AGPL).
 * See License.AGPL.txt in the project root for license information.
 */

// @generated by protoc-gen-es v1.3.3 with parameter "target=ts"
// @generated from file gitpod/v1/error.proto (package gitpod.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Describes the cause of the error with structured details to further classify the error.
 *
 * Example of a PERMISSION_DENIED status when a user is blocked
 *      { "reason": "REASON_USER_BLOCKED" }
 *
 * Example of a PERMISSION_DENIED status when a user is not verified
 *      { "reason": "REASON_NEEDS_VERIFICATION" }
 *
 * Example of FAILED_PRECONDITION status when an org payment limit is reached
 *      { "reason": "REASON_PAYMENT_SPENDING_LIMIT_REACHEAD" }
 *
 *
 * @generated from message gitpod.v1.ErrorInfo
 */
export class ErrorInfo extends Message<ErrorInfo> {
  /**
   * The reason of the error.
   *
   * @generated from field: gitpod.v1.ErrorInfo.Reason reason = 1;
   */
  reason = ErrorInfo_Reason.UNSPECIFIED;

  /**
   * @generated from field: map<string, string> metadata = 2;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ErrorInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gitpod.v1.ErrorInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "enum", T: proto3.getEnumType(ErrorInfo_Reason) },
    { no: 2, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorInfo {
    return new ErrorInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorInfo {
    return new ErrorInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorInfo {
    return new ErrorInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorInfo | PlainMessage<ErrorInfo> | undefined, b: ErrorInfo | PlainMessage<ErrorInfo> | undefined): boolean {
    return proto3.util.equals(ErrorInfo, a, b);
  }
}

/**
 * @generated from enum gitpod.v1.ErrorInfo.Reason
 */
export enum ErrorInfo_Reason {
  /**
   * @generated from enum value: REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REASON_USER_BLOCKED = 1;
   */
  USER_BLOCKED = 1,

  /**
   * @generated from enum value: REASON_NEEDS_VERIFICATION = 2;
   */
  NEEDS_VERIFICATION = 2,

  /**
   * @generated from enum value: REASON_PAYMENT_SPENDING_LIMIT_REACHEAD = 3;
   */
  PAYMENT_SPENDING_LIMIT_REACHEAD = 3,

  /**
   * @generated from enum value: REASON_INVITES_DISABLED_SSO_ORGANIZATION = 4;
   */
  INVITES_DISABLED_SSO_ORGANIZATION = 4,

  /**
   * @generated from enum value: REASON_LAST_ORGANIZATION_OWNER_CANNOT_BE_REMOVED = 5;
   */
  LAST_ORGANIZATION_OWNER_CANNOT_BE_REMOVED = 5,

  /**
   * define other reasons
   *
   * @generated from enum value: REASON_MEMBER_BELONGS_TO_ORGANIZATION = 6;
   */
  MEMBER_BELONGS_TO_ORGANIZATION = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ErrorInfo_Reason)
proto3.util.setEnumType(ErrorInfo_Reason, "gitpod.v1.ErrorInfo.Reason", [
  { no: 0, name: "REASON_UNSPECIFIED" },
  { no: 1, name: "REASON_USER_BLOCKED" },
  { no: 2, name: "REASON_NEEDS_VERIFICATION" },
  { no: 3, name: "REASON_PAYMENT_SPENDING_LIMIT_REACHEAD" },
  { no: 4, name: "REASON_INVITES_DISABLED_SSO_ORGANIZATION" },
  { no: 5, name: "REASON_LAST_ORGANIZATION_OWNER_CANNOT_BE_REMOVED" },
  { no: 6, name: "REASON_MEMBER_BELONGS_TO_ORGANIZATION" },
]);

/**
 * Describes the resource that is being accessed.
 *
 * It should be used as a payload for NOT_FOUND and ALREDY_EXIST status codes.
 *
 * @generated from message gitpod.v1.ResourceInfo
 */
export class ResourceInfo extends Message<ResourceInfo> {
  /**
   * The id of the resource being accessed
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * the type of resource being accessed
   *
   * @generated from field: gitpod.v1.ResourceInfo.Type type = 2;
   */
  type = ResourceInfo_Type.UNSPECIFIED;

  /**
   * The id of the parent resource of the resource being accessed
   * For example, the parent of a member is the organization.
   *
   * @generated from field: optional string parent_id = 3;
   */
  parentId?: string;

  constructor(data?: PartialMessage<ResourceInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gitpod.v1.ResourceInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ResourceInfo_Type) },
    { no: 3, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceInfo {
    return new ResourceInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceInfo {
    return new ResourceInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceInfo {
    return new ResourceInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceInfo | PlainMessage<ResourceInfo> | undefined, b: ResourceInfo | PlainMessage<ResourceInfo> | undefined): boolean {
    return proto3.util.equals(ResourceInfo, a, b);
  }
}

/**
 * @generated from enum gitpod.v1.ResourceInfo.Type
 */
export enum ResourceInfo_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TYPE_USER = 1;
   */
  USER = 1,

  /**
   * @generated from enum value: TYPE_ORGANIZATION = 2;
   */
  ORGANIZATION = 2,

  /**
   * @generated from enum value: TYPE_CONFIGURATION = 3;
   */
  CONFIGURATION = 3,

  /**
   * @generated from enum value: TYPE_WORKSPACE = 4;
   */
  WORKSPACE = 4,

  /**
   * @generated from enum value: TYPE_ORGANIZATION_INVITE = 5;
   */
  ORGANIZATION_INVITE = 5,

  /**
   * define other resources
   *
   * @generated from enum value: TYPE_ORGANIZATION_MEMBER = 6;
   */
  ORGANIZATION_MEMBER = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ResourceInfo_Type)
proto3.util.setEnumType(ResourceInfo_Type, "gitpod.v1.ResourceInfo.Type", [
  { no: 0, name: "TYPE_UNSPECIFIED" },
  { no: 1, name: "TYPE_USER" },
  { no: 2, name: "TYPE_ORGANIZATION" },
  { no: 3, name: "TYPE_CONFIGURATION" },
  { no: 4, name: "TYPE_WORKSPACE" },
  { no: 5, name: "TYPE_ORGANIZATION_INVITE" },
  { no: 6, name: "TYPE_ORGANIZATION_MEMBER" },
]);

/**
 * Describes violations in a client request. This error type focuses on the
 * syntactic aspects of the request.
 *
 * It should be used as a payload for INVALID_ARGUMENT and OUT_OF_RANGE status codes.
 *
 * @generated from message gitpod.v1.BadRequest
 */
export class BadRequest extends Message<BadRequest> {
  /**
   * @generated from field: repeated gitpod.v1.BadRequest.FieldViolation fields = 1;
   */
  fields: BadRequest_FieldViolation[] = [];

  constructor(data?: PartialMessage<BadRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gitpod.v1.BadRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "message", T: BadRequest_FieldViolation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadRequest {
    return new BadRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadRequest {
    return new BadRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadRequest {
    return new BadRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BadRequest | PlainMessage<BadRequest> | undefined, b: BadRequest | PlainMessage<BadRequest> | undefined): boolean {
    return proto3.util.equals(BadRequest, a, b);
  }
}

/**
 * @generated from enum gitpod.v1.BadRequest.Reason
 */
export enum BadRequest_Reason {
  /**
   * @generated from enum value: REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * define other reasons
   *
   * @generated from enum value: REASON_TOO_LONG = 1;
   */
  TOO_LONG = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(BadRequest_Reason)
proto3.util.setEnumType(BadRequest_Reason, "gitpod.v1.BadRequest.Reason", [
  { no: 0, name: "REASON_UNSPECIFIED" },
  { no: 1, name: "REASON_TOO_LONG" },
]);

/**
 * A message type used to describe a single bad request field.
 *
 * @generated from message gitpod.v1.BadRequest.FieldViolation
 */
export class BadRequest_FieldViolation extends Message<BadRequest_FieldViolation> {
  /**
   * A path that leads to a field in the request body.
   *
   * @generated from field: string field_path = 1;
   */
  fieldPath = "";

  /**
   * message is a human readable description why the request element is bad.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: gitpod.v1.BadRequest.Reason reason = 3;
   */
  reason = BadRequest_Reason.UNSPECIFIED;

  constructor(data?: PartialMessage<BadRequest_FieldViolation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gitpod.v1.BadRequest.FieldViolation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "enum", T: proto3.getEnumType(BadRequest_Reason) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadRequest_FieldViolation {
    return new BadRequest_FieldViolation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadRequest_FieldViolation {
    return new BadRequest_FieldViolation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadRequest_FieldViolation {
    return new BadRequest_FieldViolation().fromJsonString(jsonString, options);
  }

  static equals(a: BadRequest_FieldViolation | PlainMessage<BadRequest_FieldViolation> | undefined, b: BadRequest_FieldViolation | PlainMessage<BadRequest_FieldViolation> | undefined): boolean {
    return proto3.util.equals(BadRequest_FieldViolation, a, b);
  }
}

/**
 * Contains metadata about the request that clients can attach when filing a bug
 * or providing other forms of feedback.
 *
 * @generated from message gitpod.v1.RequestInfo
 */
export class RequestInfo extends Message<RequestInfo> {
  /**
   * An opaque string that should only be interpreted by the service generating
   * it. For example, it can be used to identify requests in the service's logs.
   *
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  constructor(data?: PartialMessage<RequestInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gitpod.v1.RequestInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestInfo {
    return new RequestInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestInfo {
    return new RequestInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestInfo {
    return new RequestInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RequestInfo | PlainMessage<RequestInfo> | undefined, b: RequestInfo | PlainMessage<RequestInfo> | undefined): boolean {
    return proto3.util.equals(RequestInfo, a, b);
  }
}
